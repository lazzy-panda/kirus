'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _url = require('url');

var _isomorphicFetch = require('isomorphic-fetch');

var _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);

var _tunnelAgent = require('tunnel-agent');

var _tunnelAgent2 = _interopRequireDefault(_tunnelAgent);

var _proxyFromEnv = require('proxy-from-env');

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = _util2.default.debuglog('fetch');

function getProxy(url) {

    debug('fetch %s', url);

    var urlObject = (0, _url.parse)(url);
    var urlProtocol = urlObject.protocol.replace(':', '');

    var proxyUrl = (0, _proxyFromEnv.getProxyForUrl)(url);
    if (!proxyUrl) {
        debug('use no proxy');
        return {
            proxy: null,
            url: null,
            method: 'noProxy'
        };
    }

    debug('proxy %s', proxyUrl);

    var proxyObject = (0, _url.parse)(proxyUrl || '');
    var proxyProtocol = proxyObject.protocol.replace(':', '');
    var proxyPort = proxyObject.port || (proxyProtocol === 'https' ? 443 : 80);
    proxyObject.port = proxyPort;
    var tunnelMethod = urlProtocol.concat('Over').concat(capitalizeFirstLetter(proxyProtocol));

    debug('method %s', tunnelMethod);
    return {
        proxy: proxyObject,
        target: urlObject,
        method: tunnelMethod
    };
}

function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

function fetch(url) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var _getProxy = getProxy(url),
        proxy = _getProxy.proxy,
        target = _getProxy.target,
        method = _getProxy.method;

    if (method === 'noProxy' || options.agent) {
        return (0, _isomorphicFetch2.default)(url, options);
    }

    // https://github.com/request/request/blob/b12a6245d9acdb1e13c6486d427801e123fdafae/lib/tunnel.js#L124-L130
    if (method.startsWith('httpOver')) {
        target.path = target.protocol.concat('//').concat(target.host).concat(target.path);
        target.port = proxy.port;
        target.host = proxy.host;
        target.hostname = proxy.hostname;
        target.auth = proxy.auth;
        debug('request with no tunnel');
        return (0, _isomorphicFetch2.default)(target, _extends({}, options));
    }

    debug('request with tunnel');
    var tunnel = _tunnelAgent2.default[method](Object.assign({
        proxy: {
            port: proxy.port,
            host: proxy.hostname,
            proxyAuth: proxy.auth
        }
    }));
    var agent = tunnel ? { agent: tunnel } : {};

    return (0, _isomorphicFetch2.default)(url, _extends({}, options, agent));
}

fetch.default = fetch;
exports.default = fetch;